{"ast":null,"code":"'use strict';\n\n/**\n * @license Angular v<unknown>\n * (c) 2010-2024 Google LLC. https://angular.io/\n * License: MIT\n */\n/**\n * A `TaskTrackingZoneSpec` allows one to track all outstanding Tasks.\n *\n * This is useful in tests. For example to see which tasks are preventing a test from completing\n * or an automated way of releasing all of the event listeners at the end of the test.\n */\nclass TaskTrackingZoneSpec {\n  constructor() {\n    this.name = 'TaskTrackingZone';\n    this.microTasks = [];\n    this.macroTasks = [];\n    this.eventTasks = [];\n    this.properties = {\n      'TaskTrackingZone': this\n    };\n  }\n  static get() {\n    return Zone.current.get('TaskTrackingZone');\n  }\n  getTasksFor(type) {\n    switch (type) {\n      case 'microTask':\n        return this.microTasks;\n      case 'macroTask':\n        return this.macroTasks;\n      case 'eventTask':\n        return this.eventTasks;\n    }\n    throw new Error('Unknown task format: ' + type);\n  }\n  onScheduleTask(parentZoneDelegate, currentZone, targetZone, task) {\n    task['creationLocation'] = new Error(`Task '${task.type}' from '${task.source}'.`);\n    const tasks = this.getTasksFor(task.type);\n    tasks.push(task);\n    return parentZoneDelegate.scheduleTask(targetZone, task);\n  }\n  onCancelTask(parentZoneDelegate, currentZone, targetZone, task) {\n    const tasks = this.getTasksFor(task.type);\n    for (let i = 0; i < tasks.length; i++) {\n      if (tasks[i] == task) {\n        tasks.splice(i, 1);\n        break;\n      }\n    }\n    return parentZoneDelegate.cancelTask(targetZone, task);\n  }\n  onInvokeTask(parentZoneDelegate, currentZone, targetZone, task, applyThis, applyArgs) {\n    if (task.type === 'eventTask' || task.data?.isPeriodic) return parentZoneDelegate.invokeTask(targetZone, task, applyThis, applyArgs);\n    const tasks = this.getTasksFor(task.type);\n    for (let i = 0; i < tasks.length; i++) {\n      if (tasks[i] == task) {\n        tasks.splice(i, 1);\n        break;\n      }\n    }\n    return parentZoneDelegate.invokeTask(targetZone, task, applyThis, applyArgs);\n  }\n  clearEvents() {\n    while (this.eventTasks.length) {\n      Zone.current.cancelTask(this.eventTasks[0]);\n    }\n  }\n}\nfunction patchTaskTracking(Zone) {\n  // Export the class so that new instances can be created with proper\n  // constructor params.\n  Zone['TaskTrackingZoneSpec'] = TaskTrackingZoneSpec;\n}\npatchTaskTracking(Zone);","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}